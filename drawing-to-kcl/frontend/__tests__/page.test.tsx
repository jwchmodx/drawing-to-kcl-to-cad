import React from 'react';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';

import Page from '../app/page';
import {
  mockSuccessfulConvertResponse,
  mockSuccessfulModifyResponse,
  mockNetworkError,
  createMockFetchResponse,
} from './testHelpers';
import { wasmKclEngine } from '@/lib/kclEngine';
import { loadWasmInstance, resetWasmInstance } from '@/lib/wasmLoader';
import { invokeKCLRun } from '@kcl-lang/wasm-lib';

// Mock WASM dependencies
jest.mock('@/lib/wasmLoader');
jest.mock('@kcl-lang/wasm-lib', () => ({
  invokeKCLRun: jest.fn(),
}));

describe('Main Page integration', () => {
  const mockInstance = { instance: 'wasm-instance' };

  // Helper to filter out logging fetch calls
  const getApiCalls = (endpoint?: string) => {
    return (global.fetch as jest.Mock).mock.calls.filter(
      (call) => {
        const url = call[0];
        if (typeof url !== 'string') return false;
        // Filter out logging calls
        if (url.includes('127.0.0.1:7245')) return false;
        // If endpoint specified, filter by it
        if (endpoint) return url.includes(endpoint);
        return true;
      }
    );
  };

  beforeEach(() => {
    (global.fetch as jest.Mock).mockReset();
    jest.clearAllMocks();
    resetWasmInstance();
    (loadWasmInstance as jest.Mock).mockResolvedValue(mockInstance);
    (invokeKCLRun as jest.Mock).mockReturnValue('');
    
    // Allow logging fetch calls to pass through silently (for debug mode)
    // Tests should explicitly mock API calls using mockResolvedValueOnce or mockImplementation
    (global.fetch as jest.Mock).mockImplementation((url) => {
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // For unmocked API calls, return a default error response
      // Tests should override this with their own mocks
      return Promise.reject(new Error('Unmocked fetch call - test should mock this'));
    });
  });

  it('uploads an image, calls /convert, generates preview with WASM engine', async () => {
    // Arrange: Mock successful API response (without preview, as backend won't provide it)
    // Override the default mock to handle /convert endpoint
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // Mock API response for /convert
      if (typeof url === 'string' && url.includes('/convert')) {
        return Promise.resolve(createMockFetchResponse({
          id: '1',
          kcl_code: 'kcl_from_test();',
          // preview field removed - will be generated by frontend WASM engine
        }));
      }
      return Promise.reject(new Error('Unmocked fetch call'));
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    // Act: Upload image and convert
    fireEvent.change(fileInput, { target: { files: [file] } });
    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    // Assert: Should call API and display results
    await waitFor(() => {
      // Filter out logging calls and check for /convert endpoint call
      const convertCalls = (global.fetch as jest.Mock).mock.calls.filter(
        (call) => call[0] && typeof call[0] === 'string' && call[0].includes('/convert')
      );
      expect(convertCalls.length).toBeGreaterThan(0);
    });

    const convertCalls = (global.fetch as jest.Mock).mock.calls.filter(
      (call) => call[0] && typeof call[0] === 'string' && call[0].includes('/convert')
    );
    expect(convertCalls[0][0]).toMatch(/\/convert$/);

    const editor = await screen.findByLabelText(/kcl editor/i);
    expect((editor as HTMLTextAreaElement).value).toContain('kcl_from_test();');

    // Assert: WASM engine should be called to generate preview
    await waitFor(() => {
      expect(loadWasmInstance).toHaveBeenCalled();
    });

    // Note: Preview may or may not be rendered depending on WASM execution result
    // For now, we just verify that WASM engine was invoked
  });

  it('submits a modification command, calls /modify, and updates editor', async () => {
    // Arrange: Mock two API responses (convert then modify)
    let convertCalled = false;
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // First API call: convert
      if (typeof url === 'string' && url.includes('/convert') && !convertCalled) {
        convertCalled = true;
        return Promise.resolve(mockSuccessfulConvertResponse('initial_kcl();', {
          artifacts: ['solid:initial'],
          bbox: [0, 0, 0, 1, 1, 1],
          meshes: [
            {
              id: 'solid:initial',
              vertices: [[0, 0, 0], [1, 0, 0], [0, 1, 0]],
              indices: [0, 1, 2],
            },
          ],
        }));
      }
      // Second API call: modify
      if (typeof url === 'string' && url.includes('/modify')) {
        return Promise.resolve(mockSuccessfulModifyResponse('modified_kcl();', {
          artifacts: ['solid:modified'],
          bbox: [0, 0, 0, 2, 2, 2],
          meshes: [
            {
              id: 'solid:modified',
              vertices: [[0, 0, 0], [1, 0, 0], [0, 1, 0]],
              indices: [0, 1, 2],
            },
          ],
        }));
      }
      return Promise.reject(new Error('Unmocked fetch call'));
    });

    render(<Page />);

    // Act: First convert an image
    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });
    fireEvent.change(fileInput, { target: { files: [file] } });
    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    const editor = await screen.findByLabelText(/kcl editor/i);
    expect((editor as HTMLTextAreaElement).value).toContain('initial_kcl();');

    // Then modify with a command
    const commandInput = screen.getByLabelText(/modification command/i) as HTMLInputElement;
    fireEvent.change(commandInput, { target: { value: 'add window' } });
    const applyButton = screen.getByRole('button', { name: /apply command/i });
    fireEvent.click(applyButton);

    // Assert: Should call modify endpoint and update editor
    await waitFor(() => {
      const modifyCalls = getApiCalls('/modify');
      expect(modifyCalls.length).toBeGreaterThan(0);
    });

    const modifyCalls = getApiCalls('/modify');
    const secondCall = modifyCalls[0];
    expect(secondCall[0]).toMatch(/\/modify$/);
    expect(secondCall[1]?.method).toBe('PATCH');

    const body = JSON.parse(secondCall[1]?.body as string);
    expect(body.command).toBe('add window');
    expect(body.kcl_code).toContain('initial_kcl();');

    await waitFor(() => {
      expect((screen.getByLabelText(/kcl editor/i) as HTMLTextAreaElement).value).toContain('modified_kcl();');
    });

    // Preview should be generated by frontend WASM engine (may be empty initially)
    // Note: Preview is now generated in frontend, not from backend response
    await waitFor(() => {
      const previewJson = screen.queryByTestId('kcl-preview-json');
      // Preview may or may not be present depending on WASM execution
      if (previewJson) {
        expect(previewJson).toBeInTheDocument();
      }
    });
  });

  it('handles API error response on convert', async () => {
    // Arrange: Mock fetch to return error
    (global.fetch as jest.Mock).mockResolvedValueOnce(
      createMockFetchResponse({ error: 'Internal server error' }, false)
    );

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    fireEvent.change(fileInput, { target: { files: [file] } });

    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    // Assert: Should handle error gracefully (component may show error or not update)
    await waitFor(() => {
      const convertCalls = getApiCalls('/convert');
      expect(convertCalls.length).toBeGreaterThan(0);
    });
    // Component should not crash - KclEditor may not be rendered if kclCode is empty
    // which is expected behavior when API fails
    expect(screen.getByLabelText(/upload drawing image/i)).toBeInTheDocument();
  });

  it('handles network failure on convert', async () => {
    // Arrange: Mock fetch to throw network error
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // API calls should throw network error
      return mockNetworkError();
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    fireEvent.change(fileInput, { target: { files: [file] } });

    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    
    // Act: Click convert (will trigger network error, but should be caught)
    fireEvent.click(convertButton);

    // Assert: Should handle network error gracefully
    await waitFor(() => {
      const convertCalls = getApiCalls('/convert');
      expect(convertCalls.length).toBeGreaterThan(0);
    });
    // Component should not crash - KclEditor may not be rendered if kclCode is empty
    // which is expected behavior when API fails
    expect(screen.getByLabelText(/upload drawing image/i)).toBeInTheDocument();
  });

  it('handles response without preview field', async () => {
    // Arrange: Mock response without preview
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // Mock API response
      if (typeof url === 'string' && url.includes('/convert')) {
        return Promise.resolve(createMockFetchResponse({
          id: '1',
          kcl_code: 'kcl_from_test();',
          // preview field missing
        }));
      }
      return Promise.reject(new Error('Unmocked fetch call'));
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    fireEvent.change(fileInput, { target: { files: [file] } });

    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    // Assert: Should handle missing preview
    await waitFor(() => {
      const convertCalls = getApiCalls('/convert');
      expect(convertCalls.length).toBeGreaterThan(0);
    });

    const editor = await screen.findByLabelText(/kcl editor/i);
    expect((editor as HTMLTextAreaElement).value).toContain('kcl_from_test();');
  });

  it('handles API error response on modify', async () => {
    // Arrange: Mock successful convert, then error on modify
    let convertCalled = false;
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // First API call: convert (success)
      if (typeof url === 'string' && url.includes('/convert') && !convertCalled) {
        convertCalled = true;
        return Promise.resolve(mockSuccessfulConvertResponse('initial_kcl();', { artifacts: [], bbox: null, meshes: [] }));
      }
      // Second API call: modify (error)
      if (typeof url === 'string' && url.includes('/modify')) {
        return Promise.resolve(createMockFetchResponse({ error: 'Bad request' }, false));
      }
      return Promise.reject(new Error('Unmocked fetch call'));
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });
    fireEvent.change(fileInput, { target: { files: [file] } });
    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    await waitFor(() => {
      expect(screen.getByLabelText(/kcl editor/i)).toBeInTheDocument();
    });

    const commandInput = screen.getByLabelText(/modification command/i) as HTMLInputElement;
    fireEvent.change(commandInput, { target: { value: 'add window' } });

    const applyButton = screen.getByRole('button', { name: /apply command/i });
    fireEvent.click(applyButton);

    // Assert: Should handle error gracefully
    await waitFor(() => {
      const modifyCalls = getApiCalls('/modify');
      expect(modifyCalls.length).toBeGreaterThan(0);
    });
    // Component should not crash
    expect(screen.getByLabelText(/kcl editor/i)).toBeInTheDocument();
  });

  it('handles CORS error gracefully on convert', async () => {
    // Arrange: Mock fetch to throw CORS error
    const corsError = new Error('Failed to fetch');
    (corsError as any).name = 'TypeError';
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      return Promise.reject(corsError);
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    fireEvent.change(fileInput, { target: { files: [file] } });

    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    
    // Act: Click convert (will trigger CORS error, but should be caught)
    fireEvent.click(convertButton);

    // Assert: Should handle CORS error gracefully
    await waitFor(() => {
      // Check that fetch was called (may include logging calls)
      const convertCalls = (global.fetch as jest.Mock).mock.calls.filter(
        (call) => call[0] && typeof call[0] === 'string' && call[0].includes('/convert')
      );
      expect(convertCalls.length).toBeGreaterThan(0);
    }, { timeout: 3000 });
    // Component should not crash - error should be displayed
    expect(screen.getByLabelText(/upload drawing image/i)).toBeInTheDocument();
  });

  it('handles network failure on modify', async () => {
    // Arrange: Mock successful convert, then network error on modify
    let convertCalled = false;
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // First call: convert (success)
      if (typeof url === 'string' && url.includes('/convert') && !convertCalled) {
        convertCalled = true;
        return Promise.resolve(mockSuccessfulConvertResponse('initial_kcl();', { artifacts: [], bbox: null, meshes: [] }));
      }
      // Second call: modify (error)
      if (typeof url === 'string' && url.includes('/modify')) {
        return mockNetworkError();
      }
      return Promise.reject(new Error('Unmocked fetch call'));
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });
    fireEvent.change(fileInput, { target: { files: [file] } });
    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    await waitFor(() => {
      expect(screen.getByLabelText(/kcl editor/i)).toBeInTheDocument();
    });

    const commandInput = screen.getByLabelText(/modification command/i) as HTMLInputElement;
    fireEvent.change(commandInput, { target: { value: 'add window' } });

    const applyButton = screen.getByRole('button', { name: /apply command/i });
    
    // Act: Click apply (will trigger network error, but should be caught)
    fireEvent.click(applyButton);

    // Assert: Should handle network error gracefully
    await waitFor(() => {
      // Check that modify endpoint was called
      const modifyCalls = (global.fetch as jest.Mock).mock.calls.filter(
        (call) => call[0] && typeof call[0] === 'string' && call[0].includes('/modify')
      );
      expect(modifyCalls.length).toBeGreaterThan(0);
    }, { timeout: 3000 });
    // Component should not crash
    expect(screen.getByLabelText(/kcl editor/i)).toBeInTheDocument();
  });

  it('displays error message when network error occurs', async () => {
    // Arrange: Mock fetch to throw network error for API calls, allow logging calls
    (global.fetch as jest.Mock).mockImplementation((url) => {
      // Allow logging fetch calls to pass through
      if (typeof url === 'string' && url.includes('127.0.0.1:7245')) {
        return Promise.resolve({ ok: true } as Response);
      }
      // API calls should throw network error
      return mockNetworkError();
    });

    render(<Page />);

    const fileInput = screen.getByLabelText(/upload drawing image/i) as HTMLInputElement;
    const file = new File(['dummy'], 'drawing.png', { type: 'image/png' });

    // Act: Select file and click convert button
    fireEvent.change(fileInput, { target: { files: [file] } });
    const convertButton = screen.getByRole('button', { name: /convert to kcl/i });
    fireEvent.click(convertButton);

    // Assert: Fetch should be called (may be called multiple times due to logging)
    await waitFor(() => {
      // Verify that at least one call was to /convert endpoint
      const convertCalls = (global.fetch as jest.Mock).mock.calls.filter(
        (call) => call[0] && typeof call[0] === 'string' && call[0].includes('/convert')
      );
      expect(convertCalls.length).toBeGreaterThan(0);
    }, { timeout: 3000 });
    
    // Component should not crash - error should be displayed
    expect(screen.getByLabelText(/upload drawing image/i)).toBeInTheDocument();
  });
});

